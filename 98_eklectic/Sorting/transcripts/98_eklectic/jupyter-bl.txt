# 3D Edge Navigation Models - Multiple Platforms

## 3. Jupyter Notebook Code

# Edge Navigation 3D Model in Jupyter
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import plotly.graph_objects as go
import plotly.express as px

# Parameters
distance = np.linspace(0, 10, 100)
risk_tolerance = np.linspace(0.1, 1.0, 50)
adaptability = 0.7
chaos_point = 5.0

D, R = np.meshgrid(distance, risk_tolerance)
dist_from_chaos = np.abs(D - chaos_point)

# Vectorized performance function
def calculate_performance(D, R, dist_from_chaos):
    Performance = np.zeros_like(D)
    
    # Comfort zone
    comfort_mask = dist_from_chaos > 3
    Performance[comfort_mask] = 0.6 + 0.1 * np.sin(D[comfort_mask])
    
    # Edge zone
    edge_mask = (dist_from_chaos <= 3) & (dist_from_chaos > R)
    edge_factor = (3 - dist_from_chaos[edge_mask]) / 3
    Performance[edge_mask] = 0.6 + 0.4 * edge_factor * adaptability
    
    # Chaos zone
    chaos_mask = dist_from_chaos <= R
    chaos_factor = R[chaos_mask] - dist_from_chaos[chaos_mask]
    Performance[chaos_mask] = np.maximum(0.1, 0.6 - 2 * chaos_factor / R[chaos_mask])
    
    return Performance

# Calculate surfaces
Performance = calculate_performance(D, R, dist_from_chaos)
Insight = 0.3 + 0.7 * np.exp(-dist_from_chaos)
Stress = 0.2 + 0.8 * np.exp(-dist_from_chaos * 2)
Utility = Performance + Insight - Stress

# Matplotlib 3D plots
fig = plt.figure(figsize=(15, 5))

ax1 = fig.add_subplot(131, projection='3d')
surf1 = ax1.plot_surface(D, R, Performance, cmap='viridis', alpha=0.8)
ax1.set_title('Performance Surface')
ax1.set_xlabel('Distance from Chaos')
ax1.set_ylabel('Risk Tolerance')
ax1.set_zlabel('Performance')

ax2 = fig.add_subplot(132, projection='3d')
surf2 = ax2.plot_surface(D, R, Insight, cmap='plasma', alpha=0.8)
ax2.set_title('Insight Surface')
ax2.set_xlabel('Distance from Chaos')
ax2.set_ylabel('Risk Tolerance')
ax2.set_zlabel('Insight')

ax3 = fig.add_subplot(133, projection='3d')
surf3 = ax3.plot_surface(D, R, Utility, cmap='RdYlBu', alpha=0.8)
ax3.set_title('Total Utility Surface')
ax3.set_xlabel('Distance from Chaos')
ax3.set_ylabel('Risk Tolerance')
ax3.set_zlabel('Utility')

plt.tight_layout()
plt.show()

# Interactive Plotly version
fig_plotly = go.Figure()

fig_plotly.add_trace(go.Surface(
    x=distance,
    y=risk_tolerance,
    z=Utility,
    colorscale='RdYlBu',
    name='Utility Surface'
))

fig_plotly.update_layout(
    title='Interactive 3D Utility Surface',
    scene=dict(
        xaxis_title='Distance from Chaos',
        yaxis_title='Risk Tolerance',
        zaxis_title='Utility'
    ),
    width=800,
    height=600
)

fig_plotly.show()

# Export for Blender (OBJ format)
def export_obj(filename, vertices, faces):
    with open(filename, 'w') as f:
        # Write vertices
        for v in vertices:
            f.write(f"v {v[0]} {v[1]} {v[2]}\n")
        
        # Write faces (1-indexed)
        for face in faces:
            f.write(f"f {face[0]+1} {face[1]+1} {face[2]+1}\n")

# Convert to vertices and faces
vertices = []
faces = []

for i in range(len(risk_tolerance)):
    for j in range(len(distance)):
        vertices.append([distance[j], risk_tolerance[i], Utility[i, j]])

# Create triangular faces
for i in range(len(risk_tolerance)-1):
    for j in range(len(distance)-1):
        v1 = i * len(distance) + j
        v2 = v1 + 1
        v3 = (i + 1) * len(distance) + j
        v4 = v3 + 1
        
        faces.append([v1, v2, v3])
        faces.append([v2, v4, v3])

export_obj('utility_surface.obj', vertices, faces)

# Also save as NumPy arrays
np.savez('edge_navigation_3d.npz', 
         distance=distance,
         risk_tolerance=risk_tolerance,
         performance=Performance,
         insight=Insight,
         stress=Stress,
         utility=Utility)

print("Data exported successfully!")
print("Files created:")
print("- utility_surface.obj (for Blender)")
print("- edge_navigation_3d.npz (NumPy arrays)")
