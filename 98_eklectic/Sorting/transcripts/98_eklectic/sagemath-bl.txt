# 3D Edge Navigation Models - Multiple Platforms
## 2. SageMath Code

# Edge Navigation 3D Model in SageMath
import numpy as np
from sage.plot.plot3d.plot3d import plot3d

# Parameters
distance_vals = np.linspace(0, 10, 100)
risk_tolerance_vals = np.linspace(0.1, 1.0, 50)
adaptability = 0.7
chaos_point = 5.0

# Define functions
def performance_func(d, r):
    dist_from_chaos = abs(d - chaos_point)
    
    if dist_from_chaos > 3:
        # Comfort zone
        return 0.6 + 0.1 * sin(d)
    elif dist_from_chaos > r:
        # Edge zone
        edge_factor = (3 - dist_from_chaos) / 3
        return 0.6 + 0.4 * edge_factor * adaptability
    else:
        # Chaos zone
        chaos_factor = r - dist_from_chaos
        return max(0.1, 0.6 - 2 * chaos_factor / r)

def insight_func(d, r):
    dist_from_chaos = abs(d - chaos_point)
    return 0.3 + 0.7 * exp(-dist_from_chaos)

def stress_func(d, r):
    dist_from_chaos = abs(d - chaos_point)
    return 0.2 + 0.8 * exp(-dist_from_chaos * 2)

def utility_func(d, r):
    return performance_func(d, r) + insight_func(d, r) - stress_func(d, r)

# Create 3D plots
p1 = plot3d(performance_func, (0, 10), (0.1, 1.0), 
           plot_points=[50, 25], title="Performance Surface")

p2 = plot3d(insight_func, (0, 10), (0.1, 1.0), 
           plot_points=[50, 25], title="Insight Surface")

p3 = plot3d(utility_func, (0, 10), (0.1, 1.0), 
           plot_points=[50, 25], title="Utility Surface")

# Show plots
show(p1)
show(p2)
show(p3)

# Export data
D, R = np.meshgrid(distance_vals, risk_tolerance_vals)
Performance = np.array([[performance_func(d, r) for d in distance_vals] 
                       for r in risk_tolerance_vals])
Insight = np.array([[insight_func(d, r) for d in distance_vals] 
                   for r in risk_tolerance_vals])
Utility = np.array([[utility_func(d, r) for d in distance_vals] 
                   for r in risk_tolerance_vals])

# Save as PLY format for Blender
import struct

def save_ply(filename, vertices, faces):
    with open(filename, 'wb') as f:
        # PLY header
        f.write(b'ply\n')
        f.write(b'format binary_little_endian 1.0\n')
        f.write(f'element vertex {len(vertices)}\n'.encode())
        f.write(b'property float x\n')
        f.write(b'property float y\n')
        f.write(b'property float z\n')
        f.write(f'element face {len(faces)}\n'.encode())
        f.write(b'property list uchar int vertex_indices\n')
        f.write(b'end_header\n')
        
        # Vertices
        for v in vertices:
            f.write(struct.pack('<fff', v[0], v[1], v[2]))
        
        # Faces
        for face in faces:
            f.write(struct.pack('<B', 3))  # Triangle
            f.write(struct.pack('<III', face[0], face[1], face[2]))

# Convert surfaces to vertices and faces for Blender
vertices = []
faces = []
vertex_index = 0

# Create vertices from utility surface
for i in range(len(risk_tolerance_vals)):
    for j in range(len(distance_vals)):
        vertices.append([distance_vals[j], risk_tolerance_vals[i], Utility[i][j]])

# Create faces (triangles)
for i in range(len(risk_tolerance_vals)-1):
    for j in range(len(distance_vals)-1):
        # Two triangles per quad
        v1 = i * len(distance_vals) + j
        v2 = v1 + 1
        v3 = (i + 1) * len(distance_vals) + j
        v4 = v3 + 1
        
        faces.append([v1, v2, v3])
        faces.append([v2, v4, v3])

save_ply('utility_surface.ply', vertices, faces)
